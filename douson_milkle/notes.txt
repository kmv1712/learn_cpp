30.09.2020
    В vim
        yy или Y для копирования строки
        или
        dd удалить (обрезать) линию
        затем
        p для вставки скопированного или удаленного текста после текущей строки
        P для вставки перед текущей строкой

        :set tabstop=4 - Чтобы в vim установить 4 пробела при нажатие tab

    С++ 
        Для компиляции в linux, можно вызвать команду:
        g++ -Wall -o hello hello.cpp
            g++ - компилятор для языка программирования C++
            -Wall - ключ вывода всех предупреждений компилятора
            -o hello - с посощью ключа -o указывается имя выходного файла;
            hello.cpp имя нашего исходного файла, который компилироуем

    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.43

30.09.2020
    Вечер

    Из книги:
       1) Стараться давть имя переменым не более 15 символов
       2) typdef unsigned short int unshort; - определяет новый тип ushort соответсвуюий короткому не отрицательному целому числу;

    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.54

01.10.2020
    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.64

02.10.2020
    Интересно, что в switch надо после каждой инструкции ставить break, чтобы 
    не было дальнейшей проверки по кейсам.
    В switch есть значение default 
    
    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.74

03.10.2020
    Прочел книгу "Изучаем С++ через программирование игр" до:
	стр.84
    
12.10.2020
    Vim:
         Чтобы настроить табуляцию в vim(https://rtfm.co.ua/vim-izmenit-otstupy-dlya-tab/) 
         1) Надо создать ~/.vimmrc 
         2) Записать в файл vimmrc следующие команды:
            set tabstop=4
            set shiftwidth=4
            set softtabstop=4
            set expandtab 
            set smartindent
    Прочитал:
        1) Вектор динамический массив.
        2) Нельзя после инициализации присваиваить по индексу значение в вектор, надо исользовать push_back()
        3) push_back() - добавить значение в vector
           pop_back() - удалить 
           clear() - очистить vector
14.10.2020
   Прочитал:
        Узнал, что бывают константные итераторы это которые могут только читать, но не могут изменять последовательность и простые итераторы
        Узнал. что у vector есть методы 
            erase(вставить по позиции), 
            insert(вставить в начало), если вектор большой то вставка в начало может повлиять на производительность и в таком случае лучше list
            reserve(зарезервировать память, если не использовать то вектор увеличивает память в 2 раза если превышена емкость vector)
            capacity(получить емкость вектора)
        *MyIter.size() то же что и MyIter -> size()
        Есть последовательные контейнеры например vector
        есть ассоцитивные контейнеры например map
        есть Адаптер например queue
21.10.2020
    Прочитал до 200 стр. читал про ссылки, что они из себя представляют, как их лучше передавать в функцию (стр.193)

24.10.2020
    Разбирамся с сылками 
        int playerScore = 1000;
        int& rScore = playerScore; // Создание ссылки

        int& rScore; //!!! НЕЛЬЗЯ ИНИЗИАЛИЗИРОВАТЬ ССЫЛКУ БЕЗ УКАЗАНИЯ ЗНАЧЕНИЯ 

        остановился на доступе к значениям по ссылке стр.186

26.10.2020
    Прочитал:
        Значение на которое ссылается ссылка можно переписать, если мы не хотим. чтобы оно переписывалось, то нужно создавать константную ссылку const int& mikePoint = myPoint;
        Если требуется создать ссылку на константу, то используем только константную ссылку, т.к. константу переписвать во время выполнения кода нельзя.
        Если попытаться изменить константную ссылку то получим ошибку компиляции.
        
    Аргуметны можно предовать в функию по
    1) По значению
    2) В качестве константной ссылки
    3) По Ссылке

    Боллее подробно:
    1) По значению - При передачи переменной по значени. происходит копирование перемменой, поэтому 
    2) В качестве константной ссылки - лучше передовать, для производительности т.к. не происходит копирование переменой, если нам не надо переписывать значение переменой на которую ссылается ссылка.
    3) По ссылке - Если хотим изминенять значение переменой на которую ссыллается ссылка.

    Возврат ссылок:
        При предачи и возращения значения из функции мы получаем копию, а не само значение. Ничего страшнорго если мы работаем с маленьким объектов или одним из примитивов (int, bool) , но если мы работаем с крупными объектами то лучше использовать ссылки на эти объекты, чем передавать их копии.
        
        Если мы хотим, чтобы нам функция возращала ссылку на значение, а не копию этого значения тогда надо после типа указывать & Напрмер string& refToElement().
        
        Заголовок функции и  ее прототип определяю что будет возвращать функция объект или ссылку на объект.
        
        
        НЕЛЬЗЯ возвращать ссылку на локальный объект функции т.к. после выполнения функции он будет удален и функции будет не на что ссылаться 
        т.е. так делать нельзя:
        string& badReference()
        {
            string local = "Переменная внутри функции";
            return local;
        }

    
    Указатели:

        * - астерикс
        int* pAPoiner; // инициализаця указатея.

        int* pScore = 0; // объялние и инициализция указателя (нулевой указатель)        pScore = &score; // присвоить указатею адрес переменной score
        в данном случае & это оператор взятия адреса

        Разыменование указателей:
            Для получения доступа к объекту, на который указывает итератор, этот итератор необходимо разыменовать.

            Оперция разыменования применяется для обращения к объекту, на который направлен указатель.

            Разыменование указателя выполняется с помощью *

            *pScore означает объект, на который указывает pScore

            !!! НЕЛЬЗЯ разыменовывать нулевой указатель.

            Очень нимательно работать с адресом и следить, чтобы случайно не добавить к адрсу например 500 т.е. pScore += 500 это неверно т.к. pScore это адре на память компьютера.

            В отличие от ссылок, указатели могут быть направлены на разные объекты в различные периоды жизненого цикла программы.

            pScore = &newScore // переписал на другой адес pScore, в результате pScore теперь указывает на newScore

            *pScore = newScore;// НЕНАДО так делать т.к. это бесмыслено, мы не изменим сам указатель, а изменим значение в данный момент далее.

            (*pStr).size() аналогично pStr -> size() 


            Понятие об указателях и констнтах.
            
            Чтобы ограничить функционал указателя с ним можно использовать слово const
            
            int score = 100;
            int* const pScore = &score; // константный указатель - адрес, сохранненый в константном указателе, не может измениться

            int* const pScore; // НЕДОПУСТИМО - Вы должны инициализировать константный указатель

            Посколько pScore - это контантный указатель он будет напвлен на один и только один фрагмент памяти.

            pScore = &anotherScore; // НЕДОПУСТИМО - pScore не может указывать на иной объект

            *pScore = 500; - изменять само значение, на которое напрвлен констнтный указатель вполне допустимо. Помните, ограничение, налагаемое на констнтные указателе, таково: меняться неможет только сам адрес, на который напрвлен контантный указатель.
        
             По свому функционалу константный указатель напоминает ссылку. Как и ссылка, он может относиться только к тому объекту на который был направлен в момент иницилизации. 
        
            Предпочтительней ссылки чем константные указатели по Доусону

            
              



