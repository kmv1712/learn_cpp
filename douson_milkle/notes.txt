30.09.2020
    В vim
        yy или Y для копирования строки
        или
        dd удалить (обрезать) линию
        затем
        p для вставки скопированного или удаленного текста после текущей строки
        P для вставки перед текущей строкой

        :set tabstop=4 - Чтобы в vim установить 4 пробела при нажатие tab

    С++ 
        Для компиляции в linux, можно вызвать команду:
        g++ -Wall -o hello hello.cpp
            g++ - компилятор для языка программирования C++
            -Wall - ключ вывода всех предупреждений компилятора
            -o hello - с посощью ключа -o указывается имя выходного файла;
            hello.cpp имя нашего исходного файла, который компилироуем

    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.43

30.09.2020
    Вечер

    Из книги:
       1) Стараться давть имя переменым не более 15 символов
       2) typdef unsigned short int unshort; - определяет новый тип ushort соответсвуюий короткому не отрицательному целому числу;

    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.54

01.10.2020
    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.64

02.10.2020
    Интересно, что в switch надо после каждой инструкции ставить break, чтобы 
    не было дальнейшей проверки по кейсам.
    В switch есть значение default 
    
    Прочел книгу "Изучаем С++ через программирование игр" до:
        стр.74

03.10.2020
    Прочел книгу "Изучаем С++ через программирование игр" до:
	стр.84
    
12.10.2020
    Vim:
         Чтобы настроить табуляцию в vim(https://rtfm.co.ua/vim-izmenit-otstupy-dlya-tab/) 
         1) Надо создать ~/.vimmrc 
         2) Записать в файл vimmrc следующие команды:
            set tabstop=4
            set shiftwidth=4
            set softtabstop=4
            set expandtab 
            set smartindent
    Прочитал:
        1) Вектор динамический массив.
        2) Нельзя после инициализации присваиваить по индексу значение в вектор, надо исользовать push_back()
        3) push_back() - добавить значение в vector
           pop_back() - удалить 
           clear() - очистить vector
14.10.2020
   Прочитал:
        Узнал, что бывают константные итераторы это которые могут только читать, но не могут изменять последовательность и простые итераторы
        Узнал. что у vector есть методы 
            erase(вставить по позиции), 
            insert(вставить в начало), если вектор большой то вставка в начало может повлиять на производительность и в таком случае лучше list
            reserve(зарезервировать память, если не использовать то вектор увеличивает память в 2 раза если превышена емкость vector)
            capacity(получить емкость вектора)
        *MyIter.size() то же что и MyIter -> size()
        Есть последовательные контейнеры например vector
        есть ассоцитивные контейнеры например map
        есть Адаптер например queue
21.10.2020
    Прочитал до 200 стр. читал про ссылки, что они из себя представляют, как их лучше передавать в функцию (стр.193)

24.10.2020
    Разбирамся с сылками 
        int playerScore = 1000;
        int& rScore = playerScore; // Создание ссылки

        int& rScore; //!!! НЕЛЬЗЯ ИНИЗИАЛИЗИРОВАТЬ ССЫЛКУ БЕЗ УКАЗАНИЯ ЗНАЧЕНИЯ 

        остановился на доступе к значениям по ссылке стр.186

26.10.2020
    Прочитал:
        Значение на которое ссылается ссылка можно переписать, если мы не хотим. чтобы оно переписывалось, то нужно создавать константную ссылку const int& mikePoint = myPoint;
        Если требуется создать ссылку на константу, то используем только константную ссылку, т.к. константу переписвать во время выполнения кода нельзя.
        Если попытаться изменить константную ссылку то получим ошибку компиляции.
        
    Аргуметны можно предовать в функию по
    1) По значению
    2) В качестве константной ссылки
    3) По Ссылке

    Боллее подробно:
    1) По значению - При передачи переменной по значени. происходит копирование перемменой, поэтому 
    2) В качестве константной ссылки - лучше передовать, для производительности т.к. не происходит копирование переменой, если нам не надо переписывать значение переменой на которую ссылается ссылка.
    3) По ссылке - Если хотим изминенять значение переменой на которую ссыллается ссылка.

    Возврат ссылок:
        При предачи и возращения значения из функции мы получаем копию, а не само значение. Ничего страшнорго если мы работаем с маленьким объектов или одним из примитивов (int, bool) , но если мы работаем с крупными объектами то лучше использовать ссылки на эти объекты, чем передавать их копии.
        
        Если мы хотим, чтобы нам функция возращала ссылку на значение, а не копию этого значения тогда надо после типа указывать & Напрмер string& refToElement().
        
        Заголовок функции и  ее прототип определяю что будет возвращать функция объект или ссылку на объект.
        
        
        НЕЛЬЗЯ возвращать ссылку на локальный объект функции т.к. после выполнения функции он будет удален и функции будет не на что ссылаться 
        т.е. так делать нельзя:
        string& badReference()
        {
            string local = "Переменная внутри функции";
            return local;
        }

    
    Указатели:

        * - астерикс
        int* pAPoiner; // инициализаця указатея.

        int* pScore = 0; // объялние и инициализция указателя (нулевой указатель)        pScore = &score; // присвоить указатею адрес переменной score
        в данном случае & это оператор взятия адреса

        Разыменование указателей:
            Для получения доступа к объекту, на который указывает итератор, этот итератор необходимо разыменовать.

            Оперция разыменования применяется для обращения к объекту, на который направлен указатель.

            Разыменование указателя выполняется с помощью *

            *pScore означает объект, на который указывает pScore

            !!! НЕЛЬЗЯ разыменовывать нулевой указатель.

            Очень нимательно работать с адресом и следить, чтобы случайно не добавить к адрсу например 500 т.е. pScore += 500 это неверно т.к. pScore это адре на память компьютера.

            В отличие от ссылок, указатели могут быть направлены на разные объекты в различные периоды жизненого цикла программы.

            pScore = &newScore // переписал на другой адес pScore, в результате pScore теперь указывает на newScore

            *pScore = newScore;// НЕНАДО так делать т.к. это бесмыслено, мы не изменим сам указатель, а изменим значение в данный момент далее.

            (*pStr).size() аналогично pStr -> size() 


            Понятие об указателях и констнтах.
            
            Чтобы ограничить функционал указателя с ним можно использовать слово const
            
            int score = 100;
            int* const pScore = &score; // константный указатель - адрес, сохранненый в константном указателе, не может измениться

            int* const pScore; // НЕДОПУСТИМО - Вы должны инициализировать константный указатель

            Посколько pScore - это контантный указатель он будет напвлен на один и только один фрагмент памяти.

            pScore = &anotherScore; // НЕДОПУСТИМО - pScore не может указывать на иной объект

            *pScore = 500; - изменять само значение, на которое напрвлен констнтный указатель вполне допустимо. Помните, ограничение, налагаемое на констнтные указателе, таково: меняться неможет только сам адрес, на который напрвлен контантный указатель.
        
             По свому функционалу константный указатель напоминает ссылку. Как и ссылка, он может относиться только к тому объекту на который был направлен в момент иницилизации. 
        
            Предпочтительней ссылки чем константные указатели по Доусону

27.10.2020
    Читаю:
        Использование указателя на константу
            const int* pNumber; // указатель на константу. нельзя изменить значение на которое направлен указатель
            
            int lives = 3;
            pNumber = &lives;
            *pNumber -= 1; // недопустимо указатель на константу не может поменяться 
            
            Хоть значение на которое указывает указатель менять нельзя, но можно меняь саму константу
            
            const int MAX_LIVES = 5;
            pNumber = &MAX_LIVES; // сам указатель может меняться
            
        Использование константного указателя на константу
            const int* const pBONUS = &BONUS; // константный указатель на константу
            pBONUS = &MAX_LIVES; // недопустимо pBonus не может указывать на другой объект
            *pBONUS = MAX_LIVES; //  недопустимо - ельзя изменитьзначение посредствам такого указателя.
            
            Доусон рекомендует использовать константные ссылки чем константный указатель на константу
            
        
        Константы и указатели итог
            int* const p = &i;
            const int*p;
            const int* const p = &I;
            
                       
        Передача указателей
        Возврат указателей
            Не надо возращать указатель на объект внутри локальной области видимости
            
        Присвоение указателю возвращенного указателя
            string* pStr = ptrToElement(&inventory, 1);
            
            Такое присваивание очеь эффективно т.к. не требует копирования объекта
            
            
        Присвоение переменной значенияб на которое указывает возвращеный указатель
            
            string str = *(ptrToElement(&inventory, 2));
            
            В данном случае создается копия объекта на который указывает функция
            Данное присваивание, сопряженное с копированием объекта, является более затратной операцией, чем присваивание одного указателя другому.
            
        Изменение объекта посредством возвращенного указателя
            
            *pStr = "HealingPotion";
            
        Понятие о взаимоотношениях указателей и массивов
        
28.10.2020

    Читаю:
        Использование имени массива в качестве константного указателя:
            Имя массива это константный указатель на первый элемент массива, поэтому эго можно разименовать и получить первый элемент
            cout << *highScores << endl;

            чтобы объявить указатель необходимо записать его тип, далее поставить астерикс, затем имя указателя

        Итог по указателям на стр.235;
    
              
29.10.2020
    Читаю:
        Объекты, как и функции, следует считать инкапсулированными сущностями.
        
        Определение константных методов
            Константная функция - член не может изменять член данных своего класса или вызывать неконстантную функцию член своего класса.
            Чтобы объявить константный метод можно поставить в конце заголовка слово const
            int GetHunger() const;

        Использование статических членов данных и функций-членов
            
        Объявление и инициализация статических членов данных
            Статический член данных - это отдельно взятый член, являющийся глобальным в своем классе.
            static int s_Total;// объявление переменной статического члена
            int Critter:: s_Total = 0; // инициализация переменной статического члена.
        Обращение к статическим членам данных
            cout << Critter::s_Total << "\n\n";
        Объявление и определение статических функций-членов
            Статическая функция-член является глобальной для всего класса.
            static int GetTotal(); //прототип статической функции-члена
            int Critter::GetTotal() // определение статической функции-члена
            {
                return s_Total;
            }
            Статическая функция-член не может обращаться к нестатическим членам данных. 
            Статическая функция-член является глобальной в пределах класса и не ассоциирована с каким либо конкретным экземпляром этого класса
            
        Вызов статических функций-членов
            Поскольку статические функции-члены являются глобальными в пределах своего класса, можно вызвать статическую функцию член даже в том случае, если не одного экземпляра ее класса в данный момент не существует.
            
                
02.11.2020
    Читаю:
        Создание дружественных функций
            friend void Peek(const Critter& aCritter);
            void Peek(const Critter& aCritter)
            {
                cout << aCritter.m_Name << endl;
            }
            
        Перегрузка операторов
            ostream& operator<<(ostream& os, const Critter& aCritter)
            {
                os << "Critter Object - ";
                os << "m_Name: " << aCritter.m_Name;
                return os;
            }
        
        Динамическая память 
            Стек и куча(свободное хранилище)
            
            Оператор new выделяет память в куче и возвращает ее адрес.
            После опреатора new следует указать тип значеия, для которого вы хотитие зарезевировать место.
            int* pHeap = new int;
            
            Утечка памяти
                            


    
